module godwit.make;

import std.string;
import godwit.mem;
import std.file;
import std.algorithm;
import std.stdio : writeln;
import std.traits;
import std.conv;
import std.meta;
import std.array;

private static pure string toPascalCase(string input) 
{
    auto words = input.split(".");
    auto result = appender!string;

    foreach (word; words) 
    {
        if (!word.empty)
            result.put(toUpper(word[0]).to!string~word[1..$]~".");
    }

    return result.data[0..$-1];
}

/**
    Automatic C# and .h binding generator.

    Remarks:
        Same requirements as `godwit.llv.traits.imports` \
        Depends on Godwit.Importer for C# \
        Depends on types having accessors generated using `mixin accessors`
*/
public template make(alias root, string dest)
{
    // TODO: Generic instantiations
    //       Inherits (actual inherits & subtypes [alias this])
    //       Fixed size arrays
    final void csharp(string[] inherits...) 
    {
        const string rootName = fullyQualifiedName!root;
        const string cs = dest~"\\csharp\\"~rootName;
        foreach (mod; imports!root)
        {
            string modName = fullyQualifiedName!mod;
            string path = cs~"\\"~modName~"\\";
            if (path.exists)
                path.rmdirRecurse;
            path.mkdirRecurse;

            string prev;
            // First 3 are pretty much guaranteed to be modules
            foreach (type; __traits(allMembers, mod)[2..$])
            {
                alias T = __traits(getMember, mod, type);
                static if (isType!T && !__traits(isTemplate, T) && isAggregateType!T)
                {
                    string file = path~type~".cs";
                    if (prev != file && prev != null)
                        prev.append("\n}");
                    prev = file;

                    if (inherits.length != 0)
                        file.append("// Auto generated by godwit.make\nnamespace "~(fullyQualifiedName!root).toPascalCase()~";\n\npublic unsafe class "~type~" : "~inherits.joiner(", ").array.to!string~"\n{\n");
                    else 
                        file.append("// Auto generated by godwit.make\nnamespace "~(fullyQualifiedName!root).toPascalCase()~";\n\npublic unsafe class "~type~"\n{\n");

                    foreach (member; __traits(allMembers, T))
                    {
                        alias A = __traits(getMember, T, member);
                        static if (isType!A && is(A == enum))
                        {
                            alias J = OriginalType!(typeof(__traits(getMember, A, __traits(allMembers, A)[0])));
                            string enumType = fullyQualifiedName!J.replace("ubyte", "byte");

                            static if (staticIndexOf!(flags, __traits(getAttributes, A)) != -1)
                                file.append("    [Flags]\n    public enum "~__traits(identifier, A)~" : "~enumType~"\n    {\n");
                            else
                                file.append("    public enum "~__traits(identifier, A)~" : "~enumType~"\n    {\n");

                            foreach (memenum; __traits(allMembers, A))
                                file.append("        "~memenum~" = "~(cast(J)__traits(getMember, A, memenum)).to!string~",\n");
                            file.append("    }\n\n");
                            
                        }
                        else static if (isCallable!A && isFunction!A && isExport!A)
                        {
                            string retType = (fullyQualifiedName!(ReturnType!A)).pragmatize()
                                .replace("PTR", "*")
                                .replace("OPBRK", "[")
                                .replace("CLBRK", "]")
                                .replace("COMMA", ",")
                                .replace("EXCLM", "!");
                            string generics = retType.findSplitAfter("!").array.to!string;
                            string mangle = type~"_"~__traits(identifier, A);
                            bool isFixedArray = retType.indexOf(']') != retType.indexOf('[') + 1; 
                            writeln(isFixedArray, type);

                            if (retType.endsWith('*'))
                                file.append("    public "~retType~" "~__traits(identifier, A)~" { get { return ("~retType~")Core.Importer.Call<nint>(\""~mangle~"_get\", _ptr); } set { Core.Importer.Call<nint>(\""~mangle~"_get\", _ptr, (nint)value); } }\n");
                            else
                                file.append("    public "~retType~" "~__traits(identifier, A)~" { get { return Core.Importer.Call<"~retType~">(\""~mangle~"_get\", _ptr); } set { Core.Importer.Call<"~retType~">(\""~mangle~"_get\", _ptr, value); } }\n");
                        }
                    }
                }
            }
            if (prev != null)
                prev.append("\n}");
        }
    }
}